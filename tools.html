<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Archicad → Sketchfab Fix | Исправление .dae и текстур (офлайн)</title>

<link rel="icon" href="file_0000000030986246a48be624a539648a.webp" type="image/webp" />
<link rel="canonical" href="https://0vchina.github.io/partfolio/tools.html" />

<meta name="description" content="Онлайн-фикс экспорта Archicad → Sketchfab: транслит кириллицы, переименование текстур и правка .dae. Работает офлайн в браузере. Выдаёт ZIP с максимальным сжатием."/>
<meta name="keywords" content="Archicad, Sketchfab, dae, текстуры, fix, кириллица, Collada, textures not loading"/>

<meta property="og:title" content="Archicad → Sketchfab Fix — офлайн-инструмент" />
<meta property="og:description" content="Исправляет .dae и имена текстур после экспорта из Archicad для Sketchfab. Бесплатно, офлайн, прямо в браузере. ZIP с максимальным сжатием." />
<meta property="og:image" content="https://0vchina.github.io/partfolio/tool-preview.webp" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://0vchina.github.io/partfolio/tools.html" />

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{ --accent:#1CAAD9; --panel:#ffffffc8; --brd:#00000014; --shadow:0 10px 28px rgba(0,0,0,.16); }
  *{box-sizing:border-box}
  body{ margin:0; font-family:Inter,system-ui,Segoe UI,Arial,sans-serif; color:#0d0d0d; background:#0c1216 url('a2.webp') center/cover fixed no-repeat; }
  header{position:sticky;top:0;z-index:10;background:#ffffffb8;backdrop-filter:blur(6px);border-bottom:1px solid var(--brd)}
  .wrap{max-width:1100px;margin:0 auto;padding:12px 14px}
  nav a{margin-right:12px;color:#0d0d0d;text-decoration:none;font-weight:700;border-bottom:2px solid transparent;padding-bottom:2px}
  nav a:hover{border-color:var(--accent)}
  h1{margin:.2rem 0;font-size:1.55rem;font-weight:800}
  main{max-width:1100px;margin:14px auto;padding:0 14px}
  section{ background:var(--panel); border:1px solid var(--brd); border-radius:14px; box-shadow:var(--shadow); padding:14px; margin:12px 0; }
  .grid{display:grid; gap:12px}
  @media(min-width:900px){ .grid-2{grid-template-columns:1.1fr .9fr} }
  h2{font-size:1.1rem;margin:.2rem 0 8px}
  p{line-height:1.6;margin:.4rem 0}
  .drop{ border:2px dashed #7ad7f0; border-radius:14px; padding:16px; text-align:center; background:#f8feff; color:#001018; }
  .drop.drag{ background:#e9fbff; border-color:#1CAAD9 }
  .hint{font-size:.95rem;opacity:.85}
  .row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
  .btn{ border:1px solid var(--brd); background:#fff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.1); }
  .btn.primary{ background:linear-gradient(90deg,#1CAAD9,#7AD7F0); color:#001018; }
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .files, .log{font-family:ui-monospace,Consolas,monospace;font-size:.92rem;border-radius:10px}
  .files{background:#fff;border:1px solid var(--brd);padding:10px;max-height:240px;overflow:auto}
  .log{background:#0b141a;color:#d6f0ff;padding:12px;max-height:360px;overflow:auto;border:1px solid #0f2833}
  .stat{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px;margin-top:10px}
  .pill{background:#fff;border:1px solid var(--brd);border-radius:999px;padding:6px 10px;font-weight:700}
  footer{color:#fff;opacity:.85;text-align:center;padding:20px}
  .credit{margin-top:8px}
  .credit-badge{display:inline-flex;gap:10px;align-items:center;background:#fff;border:1px solid var(--brd);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow);color:#001018;font-weight:800}
  .credit-badge .pill{background:linear-gradient(90deg,#1CAAD9,#7AD7F0);padding:4px 10px;border-radius:999px}
  details.help {background:#fff;border:1px solid var(--brd);border-radius:12px;padding:8px}
  details.help summary{cursor:pointer;font-weight:700;list-style:none}
  details.help summary::-webkit-details-marker{display:none}
  details.help p{margin:.45rem 0}
  @media(max-width:600px){
    details.help{padding:8px}
    details.help[open] {max-height:55vh; overflow:auto}
  }
  .visually-hidden{position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <nav>
      <a href="index.html">Главная</a>
      <a href="models.html">3D и рендеры</a>
      <a href="real.html">Реальные объекты</a>
      <a href="calc.html">Расчёты</a>
      <a href="tools.html" style="border-color:var(--accent)">Инструменты</a>
    </nav>
    <h1>Archicad → Sketchfab Fix — офлайн (ZIP level 9)</h1>
    <details class="help">
      <summary>Справка (коротко)</summary>
      <p>1) Перетащите <code>.dae</code> + текстуры или один <strong>.zip</strong> (можно перетаскивать целую папку).</p>
      <p>2) Нажмите «Запустить фиксацию», затем «Скачать ZIP».</p>
      <p>Инструмент: транслит кириллицы, имена по схеме <code>prefix_1234.ext</code>, правка всех <code>&lt;init_from&gt;</code> до чистых имён (без путей). Работа полностью офлайн.</p>
      <p><strong>RAR:</strong> браузер не создаёт RAR. Используем ZIP c максимальным сжатием.</p>
    </details>
  </div>
</header>

<main>
  <section class="grid grid-2">
    <div>
      <h2>1) Загрузка</h2>
      <div id="drop" class="drop" tabindex="0" aria-label="Зона для перетаскивания файлов или папок">
        <strong>Перетащите сюда</strong> <code>.dae</code> + текстуры <em>или</em> один <strong>.zip</strong><br>
        <span class="hint">Поддержка: .zip, .dae, .png, .jpg, .jpeg, .webp, .tga, .bmp, .tif, .tiff, .dds</span>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnFiles" class="btn">Выбрать файлы…</button>
        <input id="inFiles" type="file" multiple class="visually-hidden">
        <button id="btnDir" class="btn">Выбрать папку…</button>
        <input id="inDir" type="file" webkitdirectory directory multiple class="visually-hidden">
        <button id="btnZip" class="btn">Выбрать ZIP…</button>
        <input id="inZip" type="file" accept=".zip" class="visually-hidden">
        <button id="clearBtn" class="btn">Очистить список</button>
      </div>

      <div id="filesList" class="files" style="margin-top:10px;display:none"></div>
      <p id="supportNote" class="hint" style="margin-top:6px"></p>
    </div>

    <div>
      <h2>2) Обработка</h2>
      <p class="hint">Фиксация имён и ссылок выполняется автоматически по лучшим настройкам.</p>
      <div class="row">
        <button id="runBtn" class="btn primary" disabled>Запустить фиксацию</button>
        <button id="zipBtn" class="btn" disabled>Скачать ZIP (max)</button>
      </div>
      <div class="stat" id="stat" style="display:none">
        <div class="pill" id="daeStat">DAE: —</div>
        <div class="pill" id="texStat">Текстур переименовано: —</div>
      </div>
    </div>
  </section>

  <section>
    <h2>3) Отчёт</h2>
    <div id="log" class="log">Здесь появится лог изменений…</div>
  </section>
</main>

<footer>
  <div>© 2025 Виталий Овчинников</div>
  <div class="credit">
    <div class="credit-badge"><span class="pill">Виталий Овчинников</span><span>×</span><span class="pill">GPT-5 Thinking</span></div>
  </div>
</footer>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
(() => {
  const IMAGE_EXTS = new Set([".png",".jpg",".jpeg",".webp",".tga",".bmp",".tif",".tiff",".dds"]);
  const ZIP_EXT = ".zip";
  const $ = s => document.querySelector(s);

  const logEl = $("#log"), filesListEl = $("#filesList");
  const runBtn = $("#runBtn"), zipBtn = $("#zipBtn");
  const daeStatEl = $("#daeStat"), texStatEl = $("#texStat");
  const fileMap = new Map(); // relPath -> File

  const btnFiles = $("#btnFiles"), inFiles = $("#inFiles");
  const btnDir = $("#btnDir"), inDir = $("#inDir");
  const btnZip = $("#btnZip"), inZip = $("#inZip");
  const drop = $("#drop"), supportNote = $("#supportNote");

  // ------- Helpers
  const addLog = s => { logEl.textContent += (logEl.textContent ? "\\n" : "") + s; logEl.scrollTop = logEl.scrollHeight; };
  const extOf = n => { const i=n.lastIndexOf("."); return i>=0 ? n.slice(i).toLowerCase() : ""; };
  const baseName = p => p.split(/[\\/]/).pop();

  // Транслит
  function translitBasic(s){
    const t={"А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ё":"E","Ж":"Zh","З":"Z","И":"I","Й":"Y","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"Kh","Ц":"Ts","Ч":"Ch","Ш":"Sh","Щ":"Sch","Ъ":"","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ё":"e","ж":"zh","з":"z","и":"i","й":"y","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"kh","ц":"ts","ч":"ch","ш":"sh","щ":"sch","ъ":"","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","’":"","‘":"","ʼ":""};
    return s.replace(/./g, ch => t[ch] ?? ch);
  }

  // Имя текстуры
  function normalizeTexName(name){
    const bn = baseName(name);
    const dot = bn.lastIndexOf(".");
    const stem = dot>=0 ? bn.slice(0,dot) : bn;
    const ext = dot>=0 ? bn.slice(dot) : "";
    const parts = stem.split("_");
    if(parts.length < 2) return translitBasic(bn);
    const prefix = parts[0];
    const tail = parts.slice(1).join("_");
    let digits = "";
    for(const ch of tail){ if(/\\d/.test(ch)) digits += ch; else break; }
    const result = digits ? `${prefix}_${digits}${ext}` : bn;
    return translitBasic(result);
  }

  // Правка <init_from> — только имена, без путей
  function rewriteDaeTextByMapping(text, mapping){
    let changed = 0;
    const out = text.replace(/(<init_from>\\s*)([^<]+?)(\\s*<\\/init_from>)/gi, (full,p1,inner,p3)=>{
      const raw = inner.trim()
        .replace(/^file:\\/\\//i,"")
        .replace(/^([A-Za-z]:)/, "")
        .replace(/^\\/+/, "");
      const key = baseName(raw);
      let target = mapping.get(key) || normalizeTexName(key);
      if(target !== key) changed++;
      return `${p1}${target}${p3}`;
    });
    return {text: out, count: changed};
  }

  function renderFiles(){
    if(fileMap.size===0){ filesListEl.style.display="none"; filesListEl.textContent=""; runBtn.disabled=true; return; }
    const lines=[]; let hasDae=false;
    for(const [rel,f] of fileMap.entries()){
      lines.push(`${rel} (${Math.round((f.size||0)/1024)} KB)`);
      if(extOf(rel)===".dae") hasDae=true;
    }
    filesListEl.textContent = lines.join("\\n");
    filesListEl.style.display="block";
    runBtn.disabled=!hasDae; zipBtn.disabled=true; $("#stat").style.display="none";
    daeStatEl.textContent="DAE: —"; texStatEl.textContent="Текстур переименовано: —";
  }

  // ---------- ZIP
  async function addZip(file){
    try{
      const zip = await JSZip.loadAsync(file);
      let count=0;
      await Promise.all(Object.keys(zip.files).map(async (name)=>{
        const entry = zip.files[name];
        if(entry.dir) return;
        const bn = baseName(name);
        const ext = extOf(bn);
        if(ext=== ".zip") return;
        if(ext===".dae" || IMAGE_EXTS.has(ext)){
          const blob = await entry.async("blob");
          const f = new File([blob], bn, {type: blob.type || "application/octet-stream"});
          fileMap.set(bn, f); count++;
        }
      }));
      addLog(`Загружено из ZIP: ${count} файлов.`);
    }catch(e){
      addLog("Ошибка чтения ZIP: "+e);
    }
  }

  // ---------- Рекурсивное чтение папок (drag&drop)
  async function traverseEntry(entry, path=""){
    return new Promise((resolve, reject)=>{
      if(entry.isFile){
        entry.file(file=>{
          const rel = path ? (path + "/" + file.name) : file.name;
          fileMap.set(rel, file);
          resolve();
        }, reject);
      } else if(entry.isDirectory){
        const reader = entry.createReader();
        const entries = [];
        const readBatch = () => {
          reader.readEntries(async results=>{
            if(!results.length){
              const tasks=[];
              for(const e of entries){ tasks.push(traverseEntry(e, path ? (path + "/" + entry.name) : entry.name)); }
              Promise.all(tasks).then(()=>resolve()).catch(reject);
            } else {
              entries.push(...results); readBatch();
            }
          }, reject);
        };
        readBatch();
      } else { resolve(); }
    });
  }

  async function collectFromDataTransfer(dt){
    // webkitGetAsEntry
    if(dt.items && dt.items.length && dt.items[0].webkitGetAsEntry){
      const tasks=[];
      for(const it of dt.items){
        if(it.kind !== "file") continue;
        const entry = it.webkitGetAsEntry();
        if(entry) tasks.push(traverseEntry(entry));
      }
      if(tasks.length){ await Promise.all(tasks); return true; }
    }
    // fallback — просто файлы
    if(dt.files && dt.files.length){
      for(const f of dt.files){ fileMap.set(f.webkitRelativePath || f.name, f); }
      return true;
    }
    return false;
  }

  function addFilesFromFileList(list){
    for(const f of list){
      const rel = f.webkitRelativePath || f.name;
      if(extOf(rel)===".zip"){ addZip(f); } else { fileMap.set(rel, f); }
    }
    renderFiles();
  }

  // ---------- Глобальные обработчики DnD (важно!)
  ["dragover","drop"].forEach(evt=>{
    document.addEventListener(evt, e=>{
      e.preventDefault(); e.stopPropagation();
      if(evt==="dragover"){ drop.classList.add("drag"); }
      if(evt==="drop"){ drop.classList.remove("drag"); }
    }, {passive:false});
  });

  // Зона
  drop.addEventListener("dragenter", ()=> drop.classList.add("drag"));
  drop.addEventListener("dragleave", ()=> drop.classList.remove("drag"));
  drop.addEventListener("drop", async e=>{
    if(e.dataTransfer){
      const ok = await collectFromDataTransfer(e.dataTransfer);
      if(ok) renderFiles(); else addLog("Не удалось получить файлы из drop.");
    }
  });

  // Кнопки выбора
  btnFiles.addEventListener("click", ()=> inFiles.click());
  btnZip.addEventListener("click", ()=> inZip.click());
  btnDir.addEventListener("click", ()=>{
    if(!("webkitdirectory" in inDir)){
      alert("Выбор папки не поддерживается этим браузером. Откройте инструмент в Chrome или Microsoft Edge.");
      return;
    }
    inDir.click();
  });

  inFiles.addEventListener("change", e=> addFilesFromFileList(e.target.files));
  inZip  .addEventListener("change", e=> addFilesFromFileList(e.target.files));
  inDir  .addEventListener("change", e=> addFilesFromFileList(e.target.files));

  $("#clearBtn").addEventListener("click", ()=>{ fileMap.clear(); renderFiles(); logEl.textContent="Список очищен."; });

  // Подсказка по поддержке
  const supportsDir = ("webkitdirectory" in inDir);
  const supportsItems = !!DataTransferItem.prototype && "webkitGetAsEntry" in DataTransferItem.prototype;
  supportNote.textContent = `Поддержка: перетаскивание папок — ${supportsItems ? "да" : "нет (используйте Chrome/Edge)"}, выбор папки — ${supportsDir ? "да" : "нет (Chrome/Edge)"}`;

  // ---------- Обработка
  let lastZipBlob=null;

  $("#runBtn").addEventListener("click", async ()=>{
    logEl.textContent=""; lastZipBlob=null; zipBtn.disabled=true;

    let daePath=null; for(const [rel] of fileMap.entries()){ if(extOf(rel)===".dae"){ daePath=rel; break; } }
    if(!daePath){ addLog("Не найден .dae."); return; }
    addLog(`DAE: ${daePath}`);

    const mapping = new Map();
    const taken = new Set();

    for(const [rel,f] of fileMap.entries()){
      if(extOf(rel)===".dae") continue;
      if(!IMAGE_EXTS.has(extOf(rel))) continue;
      const oldBase = baseName(rel);
      let cand = normalizeTexName(oldBase);
      if(taken.has(cand)){
        let k=1, withIdx=cand;
        const dot = cand.lastIndexOf(".");
        const stem = dot>=0?cand.slice(0,dot):cand;
        const ext  = dot>=0?cand.slice(dot):"";
        while(taken.has(withIdx)){ withIdx = `${stem}-${k}${ext}`; k++; }
        cand = withIdx;
      }
      taken.add(cand);
      mapping.set(oldBase, cand);
    }

    const daeText = await fileMap.get(daePath).text();
    const {text: patchedText, count: daeFixCount} = rewriteDaeTextByMapping(daeText, mapping);
    addLog(`Обновлено ссылок в .dae: ${daeFixCount}`);

    const zip = new JSZip();
    zip.file("model_fixed.dae", patchedText);

    let renamedCount = 0;
    for(const [rel,f] of fileMap.entries()){
      if(extOf(rel)===".dae") continue;
      if(!IMAGE_EXTS.has(extOf(rel))) continue;
      const oldBase = baseName(rel);
      const newBase = mapping.get(oldBase) || normalizeTexName(oldBase);
      if(newBase !== oldBase) renamedCount++;
      const data = await f.arrayBuffer();
      zip.file(newBase, data);
      if(newBase !== oldBase) addLog(`TEX: ${oldBase} → ${newBase}`);
    }
    if(renamedCount===0) addLog("Текстуры не требуют переименования.");

    const report = [
      "Archicad → Sketchfab Fix report",
      `dae file: ${daePath}`,
      `links updated in dae: ${daeFixCount}`,
      `textures renamed: ${renamedCount}`,
      "",
      ...[...mapping.entries()].map(([o,n]) => (o===n?`=`:`*`) + ` ${o} -> ${n}`)
    ].join("\\n");
    zip.file("report.txt", report);

    lastZipBlob = await zip.generateAsync({
      type:"blob",
      compression: "DEFLATE",
      compressionOptions: { level: 9 }
    });
    zipBtn.disabled=false;

    $("#stat").style.display="grid";
    daeStatEl.textContent = `DAE: обновлено ссылок: ${daeFixCount}`;
    texStatEl.textContent = `Текстур переименовано: ${renamedCount}`;
    addLog("Готово. Скачайте ZIP и загрузите в Sketchfab.");
  });

  $("#zipBtn").addEventListener("click", ()=>{
    if(!lastZipBlob) return;
    const a=document.createElement("a");
    a.href=URL.createObjectURL(lastZipBlob);
    a.download="sketchfab_fixed.zip";
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
  });
})();
</script>
</body>
</html>
