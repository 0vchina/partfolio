<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Archicad/OBJ → Sketchfab Fix | Исправление .dae/.obj/.mtl и текстур</title>

<link rel="icon" href="file_0000000030986246a48be624a539648a.webp" type="image/webp" />
<link rel="canonical" href="https://0vchina.github.io/partfolio/tools.html" />

<!-- SEO -->
<meta name="description" content="Офлайн-инструмент для Sketchfab: чинит .dae/.obj/.mtl после экспорта. Переименовывает текстуры (транслит), правит пути в .dae и карты в .mtl, фиксирует mtllib/usemtl, собирает ZIP (DEFLATE 9). Работает прямо в браузере."/>
<meta name="keywords" content="Archicad, Sketchfab, OBJ, MTL, DAE, Collada, текстуры, кириллица, fix, BIM, textures not loading"/>

<!-- Open Graph -->
<meta property="og:title" content="Archicad/OBJ → Sketchfab Fix — офлайн-инструмент" />
<meta property="og:description" content="Исправляет .dae/.obj/.mtl и имена текстур. Транслит, нормализация, правка ссылок. ZIP с максимальным сжатием." />
<meta property="og:image" content="https://0vchina.github.io/partfolio/tool-preview.webp" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://0vchina.github.io/partfolio/tools.html" />

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{ --accent:#1CAAD9; --panel:#ffffffc8; --brd:#00000014; --shadow:0 10px 28px rgba(0,0,0,.16); }
  *{box-sizing:border-box}
  body{ margin:0; font-family:Inter,system-ui,Segoe UI,Arial,sans-serif; color:#0d0d0d; background:#0c1216 url('a2.webp') center/cover fixed no-repeat; }
  header{position:sticky;top:0;z-index:10;background:#ffffffb8;backdrop-filter:blur(6px);border-bottom:1px solid var(--brd)}
  .wrap{max-width:1100px;margin:0 auto;padding:12px 14px}
  nav a{margin-right:12px;color:#0d0d0d;text-decoration:none;font-weight:700;border-bottom:2px solid transparent;padding-bottom:2px}
  nav a:hover{border-color:var(--accent)}
  h1{margin:.2rem 0;font-size:1.6rem;font-weight:800}
  main{max-width:1100px;margin:18px auto;padding:0 14px}
  section{ background:var(--panel); border:1px solid var(--brd); border-radius:14px; box-shadow:var(--shadow); padding:16px; margin:14px 0; }
  .grid{display:grid; gap:14px}
  @media(min-width:900px){ .grid-2{grid-template-columns:1.1fr .9fr} }
  h2{font-size:1.2rem;margin:.2rem 0 8px}
  p{line-height:1.6;margin:.4rem 0}
  .drop{
    border:2px dashed #7ad7f0; border-radius:14px; padding:16px; text-align:center;
    background:#f8feff; color:#001018; cursor:pointer; user-select:none;
  }
  .drop.drag{ background:#e9fbff; border-color:#1CAAD9 }
  .hint{font-size:.95rem;opacity:.85}
  .row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
  .btn{ border:1px solid var(--brd); background:#fff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.1); }
  .btn.primary{ background:linear-gradient(90deg,#1CAAD9,#7AD7F0); color:#001018; }
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .files, .log{font-family:ui-monospace,Consolas,monospace;font-size:.92rem;border-radius:10px}
  .files{background:#fff;border:1px solid var(--brd);padding:10px;max-height:240px;overflow:auto}
  .log{background:#0b141a;color:#d6f0ff;padding:12px;max-height:360px;overflow:auto;border:1px solid #0f2833}
  .stat{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px;margin-top:10px}
  .pill{background:#fff;border:1px solid var(--brd);border-radius:999px;padding:6px 10px;font-weight:700}
  footer{color:#fff;opacity:.85;text-align:center;padding:24px}
  .credit{margin-top:8px}
  .credit-badge{display:inline-flex;gap:10px;align-items:center;background:#fff;border:1px solid var(--brd);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow);color:#001018;font-weight:800}
  .credit-badge .pill{background:linear-gradient(90deg,#1CAAD9,#7AD7F0);padding:4px 10px;border-radius:999px}

  details.seo{ background:#fff; border:1px solid var(--brd); border-radius:12px; padding:10px 12px; margin-top:10px; }
  details.seo summary{cursor:pointer; list-style:none; font-weight:800}
  details.seo summary::-webkit-details-marker{display:none}
  details.seo[open]{box-shadow:0 8px 24px rgba(0,0,0,.08)}
  .hidden{position:absolute;left:-9999px}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <nav>
      <a href="index.html">Главная</a>
      <a href="models.html">3D и рендеры</a>
      <a href="real.html">Реальные объекты</a>
      <a href="calc.html">Расчёты</a>
      <a href="tools.html" style="border-color:var(--accent)">Инструменты</a>
    </nav>
    <h1>Archicad/OBJ → Sketchfab Fix — бесплатный офлайн-инструмент</h1>
    <details class="seo">
      <summary>Справка — что делает инструмент?</summary>
      <p><strong>Назначение:</strong> исправляет «слетающие» текстуры и кириллицу после экспорта для Sketchfab.</p>
      <ul>
        <li><code>.dae</code>: чистит пути в <code>&lt;init_from&gt;</code> до имён и подставляет новые файлы.</li>
        <li><code>.obj/.mtl</code>: правит <code>mtllib</code> в OBJ; в MTL — <code>map_Kd</code>, <code>map_Ka</code>, <code>map_Ks</code>, <code>bump</code>/<code>map_Bump</code>, <code>disp</code>, <code>map_d</code>.</li>
        <li>Имена текстур: транслит + формат <code>prefix_1234.ext</code> (цифры сразу после первого <code>_</code>), уникализация при коллизиях.</li>
      </ul>
      <p>Работает локально в браузере. Архив — ZIP (DEFLATE 9). RAR браузеры не создают.</p>
      <p class="hint">Поддержка: .zip (dae/obj/mtl+textures), .dae, .obj, .mtl, .png, .jpg, .jpeg, .webp, .tga, .bmp, .tif, .tiff, .dds</p>
    </details>
  </div>
</header>

<main>
  <section class="grid grid-2">
    <div>
      <h2>1) Загрузка</h2>
      <div id="drop" class="drop" tabindex="0">
        <strong>Перетащите сюда</strong> <code>.dae</code>/<code>.obj</code> + <code>.mtl</code> + текстуры <em>или</em> один <strong>.zip</strong><br>
        <span class="hint">Можно также выбрать файлы/папку/ZIP кнопками ниже</span>
      </div>

      <div class="row">
        <button id="btnFiles" class="btn" type="button">Выбрать файлы…</button>
        <input id="inFiles" type="file" multiple class="hidden">

        <button id="btnDir" class="btn" type="button">Выбрать папку…</button>
        <input id="inDir" type="file" webkitdirectory directory multiple class="hidden">

        <button id="btnZip" class="btn" type="button">Выбрать ZIP…</button>
        <input id="inZip" type="file" accept=".zip" class="hidden">

        <button id="clearBtn" class="btn" type="button">Очистить список</button>
      </div>

      <div id="filesList" class="files" style="margin-top:10px;display:none"></div>
    </div>

    <div>
      <h2>2) Обработка</h2>
      <p class="hint">Автоматически: транслит + формат <code>prefix_1234.ext</code> + правка <code>DAE</code>/<code>OBJ</code>/<code>MTL</code></p>
      <div class="row">
        <button id="runBtn" class="btn primary" type="button" disabled>Запустить фиксацию</button>
        <button id="zipBtn" class="btn" type="button" disabled>Скачать ZIP (max)</button>
      </div>
      <div class="stat" id="stat" style="display:none">
        <div class="pill" id="daeStat">DAE: —</div>
        <div class="pill" id="objStat">OBJ/MTL: —</div>
        <div class="pill" id="texStat">Текстур переименовано: —</div>
      </div>
    </div>
  </section>

  <section>
    <h2>3) Отчёт</h2>
    <div id="log" class="log">Здесь появится лог изменений…</div>
  </section>
</main>

<footer>
  <div>© 2025 Виталий Овчинников</div>
  <div class="credit">
    <div class="credit-badge">
      <span class="pill">Виталий Овчинников</span><span>×</span><span class="pill">GPT-5 Thinking</span>
    </div>
  </div>
</footer>

<!-- JSZip -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
(() => {
  // ======= Глобальная защита DnD (чтобы браузер не открывал файл) =======
  ['dragover','drop'].forEach(evt=>{
    window.addEventListener(evt, e => { e.preventDefault(); }, { passive:false });
  });

  const IMAGE_EXTS = new Set([".png",".jpg",".jpeg",".webp",".tga",".bmp",".tif",".tiff",".dds"]);
  const TEXT_EXTS  = new Set([".mtl",".obj",".dae"]);
  const $ = sel => document.querySelector(sel);

  const logEl = $("#log"), filesListEl = $("#filesList");
  const runBtn = $("#runBtn"), zipBtn = $("#zipBtn");
  const daeStatEl = $("#daeStat"), objStatEl = $("#objStat"), texStatEl = $("#texStat");

  const drop = $("#drop");
  const btnFiles = $("#btnFiles"), inFiles = $("#inFiles");
  const btnDir = $("#btnDir"), inDir = $("#inDir");
  const btnZip = $("#btnZip"), inZip = $("#inZip");

  const fileMap = new Map(); // rel/name -> File
  let lastZipBlob = null;

  const addLog = s => { logEl.textContent += (logEl.textContent ? "\\n" : "") + s; logEl.scrollTop = logEl.scrollHeight; };
  const extOf = n => { const i=n.lastIndexOf("."); return i>=0 ? n.slice(i).toLowerCase() : ""; };
  const baseName = p => p.split(/[\\/]/).pop();

  function translitBasic(s){
    const t={"А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ё":"E","Ж":"Zh","З":"Z","И":"I","Й":"Y","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"Kh","Ц":"Ts","Ч":"Ch","Ш":"Sh","Щ":"Sch","Ъ":"","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ё":"e","ж":"zh","з":"z","и":"i","й":"y","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"kh","ц":"ts","ч":"ch","ш":"sh","щ":"sch","ъ":"","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","’":"","‘":"","ʼ":""};
    return s.replace(/./g, ch => t[ch] ?? ch);
  }

  function normalizeTexName(name){
    const bn = baseName(name);
    const dot = bn.lastIndexOf(".");
    const stem = dot>=0 ? bn.slice(0,dot) : bn;
    const ext = dot>=0 ? bn.slice(dot) : "";
    const parts = stem.split("_");
    if(parts.length < 2) return translitBasic(bn);
    const prefix = parts[0];
    const tail = parts.slice(1).join("_");
    let digits = "";
    for(const ch of tail){ if(/\\d/.test(ch)) digits += ch; else break; }
    const result = digits ? `${prefix}_${digits}${ext}` : bn;
    return translitBasic(result);
  }

  function uniquify(name, taken){
    if(!taken.has(name)){ taken.add(name); return name; }
    const dot = name.lastIndexOf(".");
    const stem = dot>=0 ? name.slice(0,dot) : name;
    const ext  = dot>=0 ? name.slice(dot) : "";
    let k=1, cand;
    do { cand = `${stem}-${k}${ext}`; k++; } while(taken.has(cand));
    taken.add(cand); return cand;
  }

  function patchDAE(text, texMap){
    let changed = 0;
    const out = text.replace(/(<init_from>\\s*)([^<]+?)(\\s*<\\/init_from>)/gi, (full,p1,inner,p3)=>{
      const raw = inner.trim().replace(/^file:\\/\\//i,"").replace(/^[A-Za-z]:/,"").replace(/^\\/+/, "");
      const key = baseName(raw);
      const target = texMap.get(key) || normalizeTexName(key);
      if(target !== key) changed++;
      return `${p1}${target}${p3}`;
    });
    return {text: out, count: changed};
  }

  function patchMTL(text, texMap, matNameMap){
    let changed = 0;
    const lines = text.split(/\\r?\\n/).map(line=>{
      const trimmed = line.trim();
      if(/^newmtl\\s+/i.test(trimmed)){
        const old = trimmed.replace(/^newmtl\\s+/i,'');
        const neu = matNameMap.get(old) || translitBasic(old);
        if(neu !== old){ changed++; return line.replace(/newmtl\\s+.*/i, `newmtl ${neu}`); }
        return line;
      }
      const key = trimmed.split(/\\s+/)[0];
      if(/^(map_Kd|map_Ka|map_Ks|bump|map_Bump|disp|map_d)$/i.test(key)){
        const parts = trimmed.split(/\\s+/);
        let path = parts[parts.length-1];
        path = path.replace(/^file:\\/\\//i,"").replace(/^[A-Za-z]:/,"").replace(/^\\/+/, "");
        const base = baseName(path);
        const target = texMap.get(base) || normalizeTexName(base);
        if(target !== base){ changed++; return line.replace(base, target); }
      }
      return line;
    });
    return {text: lines.join("\\n"), count: changed};
  }

  function patchOBJ(text, mtlNewName, matNameMap){
    let changed = 0;
    const out = text.split(/\\r?\\n/).map(line=>{
      const t = line.trim();
      if(/^mtllib\\s+/i.test(t)){
        const neu = translitBasic(mtlNewName);
        changed += (t.split(/\\s+/)[1] !== neu) ? 1 : 0;
        return line.replace(/mtllib\\s+.*/i, `mtllib ${neu}`);
      }
      if(/^usemtl\\s+/i.test(t)){
        const old = t.replace(/^usemtl\\s+/i,'');
        const neu = matNameMap.get(old) || translitBasic(old);
        changed += (neu !== old) ? 1 : 0;
        return line.replace(/usemtl\\s+.*/i, `usemtl ${neu}`);
      }
      return line;
    }).join("\\n");
    return {text: out, count: changed};
  }

  async function addZip(file){
    try{
      const zip = await JSZip.loadAsync(file);
      let count=0;
      await Promise.all(Object.keys(zip.files).map(async (name)=>{
        const entry = zip.files[name];
        if(entry.dir) return;
        const bn = baseName(name);
        const ext = extOf(bn);
        if(ext===".zip") return;
        if(TEXT_EXTS.has(ext) || IMAGE_EXTS.has(ext)){
          const blob = await entry.async("blob");
          const f = new File([blob], bn, {type: blob.type || "application/octet-stream"});
          fileMap.set(bn, f); count++;
        }
      }));
      addLog(`Загружено из ZIP: ${count} файлов.`);
      renderFiles();
    }catch(e){
      addLog("Ошибка чтения ZIP: "+e);
    }
  }

  function addFiles(list){
    for(const f of list){
      const rel = f.webkitRelativePath || f.name;
      if(extOf(rel)===".zip"){ addZip(f); } else { fileMap.set(rel, f); }
    }
    renderFiles();
  }

  function renderFiles(){
    if(fileMap.size===0){ filesListEl.style.display="none"; filesListEl.textContent=""; runBtn.disabled=true; return; }
    const lines=[]; let hasAnyModel=false;
    for(const [rel] of fileMap.entries()){
      lines.push(`${rel}`);
      const e = extOf(rel);
      if(e===".dae" || e===".obj") hasAnyModel=true;
    }
    filesListEl.textContent = lines.join("\\n");
    filesListEl.style.display="block";
    runBtn.disabled = !hasAnyModel;
    zipBtn.disabled = true;
    document.getElementById("stat").style.display="none";
    daeStatEl.textContent="DAE: —"; objStatEl.textContent="OBJ/MTL: —"; texStatEl.textContent="Текстур переименовано: —";
  }

  // ======= DnD на зоне + клик и клавиатура =======
  drop.addEventListener("click", ()=> inFiles.click());
  drop.addEventListener("keydown", e=>{
    if(e.key==="Enter" || e.key===" "){ e.preventDefault(); inFiles.click(); }
  });
  drop.addEventListener("dragover", e=>{ e.preventDefault(); drop.classList.add("drag"); });
  drop.addEventListener("dragleave", ()=> drop.classList.remove("drag"));
  drop.addEventListener("drop", e=>{
    e.preventDefault(); drop.classList.remove("drag");
    if(e.dataTransfer?.files?.length) addFiles(e.dataTransfer.files);
  });

  // Кнопки выбора
  btnFiles.addEventListener("click", ()=> inFiles.click());
  btnZip  .addEventListener("click", ()=> inZip.click());
  btnDir  .addEventListener("click", ()=>{
    if (!('webkitdirectory' in inDir)) { alert('Выбор папки не поддерживается этим браузером. Откройте в Chrome/Edge.'); return; }
    inDir.click();
  });

  inFiles.addEventListener("change", e=> addFiles(e.target.files));
  inZip  .addEventListener("change", e=> addFiles(e.target.files));
  inDir  .addEventListener("change", e=> addFiles(e.target.files));

  document.getElementById("clearBtn").addEventListener("click", ()=>{ fileMap.clear(); renderFiles(); logEl.textContent="Список очищен."; });

  // ======= Обработка =======
  document.getElementById("runBtn").addEventListener("click", async ()=>{
    logEl.textContent=""; lastZipBlob=null; zipBtn.disabled=true;

    let daeName=null, objName=null, mtlName=null;
    const textures = [];
    for(const [rel] of fileMap.entries()){
      const e = extOf(rel);
      if(e===".dae") daeName = rel;
      else if(e===".obj") objName = rel;
      else if(e===".mtl") mtlName = rel;
      else if(IMAGE_EXTS.has(e)) textures.push(rel);
    }

    const taken = new Set();
    const texMap = new Map();
    let renamedCount = 0;

    for(const rel of textures){
      const oldBase = baseName(rel);
      const first = normalizeTexName(oldBase);
      const uniq = uniquify(first, taken);
      texMap.set(oldBase, uniq);
      if(uniq !== oldBase){ renamedCount++; addLog(`TEX: ${oldBase} → ${uniq}`); }
    }

    // DAE
    let daeFixCount = 0;
    let outDAE = null;
    if(daeName){
      const daeText = await fileMap.get(daeName).text();
      const {text, count} = patchDAE(daeText, texMap);
      outDAE = text; daeFixCount = count;
      addLog(`DAE: обновлено ссылок: ${daeFixCount}`);
    }

    // OBJ/MTL
    let objMtlFixes = 0;
    let outOBJ=null, outMTL=null;
    let newObjName=null, newMtlName=null;

    if(objName){
      const objBaseOld = baseName(objName);
      const mtlBaseOld = mtlName ? baseName(mtlName) : null;

      newObjName = translitBasic(objBaseOld);
      newMtlName = translitBasic(mtlBaseOld || "materials.mtl");

      // Материалы
      const matNameMap = new Map();
      if(mtlName){
        const mtlText = await fileMap.get(mtlName).text();
        mtlText.split(/\\r?\\n/).forEach(line=>{
          const m = line.trim().match(/^newmtl\\s+(.+)$/i);
          if(m){
            const old = m[1];
            const neu = translitBasic(old);
            if(neu !== old) matNameMap.set(old, neu);
          }
        });
        const patched = patchMTL(mtlText, texMap, matNameMap);
        outMTL = patched.text; objMtlFixes += patched.count;
        addLog(`MTL: исправлено ссылок/имен: ${patched.count}`);
      }

      const objText = await fileMap.get(objName).text();
      const patchedObj = patchOBJ(objText, newMtlName, new Map(matNameMap));
      outOBJ = patchedObj.text; objMtlFixes += patchedObj.count;
      addLog(`OBJ: исправлено mtllib/usemtl: ${patchedObj.count}`);
    }

    // ZIP
    const zip = new JSZip();
    if(outDAE) zip.file("model_fixed.dae", outDAE);
    if(outMTL) zip.file(newMtlName || "materials.mtl", outMTL);
    if(outOBJ) zip.file(newObjName || "model.obj", outOBJ);

    for(const [rel,f] of fileMap.entries()){
      const e = extOf(rel);
      if(!IMAGE_EXTS.has(e)) continue;
      const oldBase = baseName(rel);
      const newBase = texMap.get(oldBase) || normalizeTexName(oldBase);
      const data = await f.arrayBuffer();
      zip.file(newBase, data);
    }

    const report = [
      "Sketchfab Fix report",
      daeName ? `dae file: ${daeName} (links fixed: ${daeFixCount})` : "dae file: —",
      objName ? `obj file: ${objName} → ${newObjName}` : "obj file: —",
      mtlName ? `mtl file: ${mtlName} → ${newMtlName}` : "mtl file: —",
      `obj/mtl changes: ${objMtlFixes}`,
      `textures renamed: ${renamedCount}`
    ].join("\\n");
    zip.file("report.txt", report);

    lastZipBlob = await zip.generateAsync({ type:"blob", compression:"DEFLATE", compressionOptions:{level:9} });
    zipBtn.disabled=false;

    document.getElementById("stat").style.display="grid";
    if(daeName) daeStatEl.textContent = `DAE: обновлено ссылок: ${daeFixCount}`;
    objStatEl.textContent = `OBJ/MTL: правок: ${objMtlFixes}`;
    texStatEl.textContent = `Текстур переименовано: ${renamedCount}`;
    addLog("Готово. Скачайте ZIP и загрузите в Sketchfab.");
  });

  document.getElementById("zipBtn").addEventListener("click", ()=>{
    if(!lastZipBlob) return;
    const a=document.createElement("a");
    a.href=URL.createObjectURL(lastZipBlob);
    a.download="sketchfab_fixed.zip";
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
  });
})();
</script>
</body>
</html>
